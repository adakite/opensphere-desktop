package io.opensphere.filterbuilder2.editor;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.List;
import java.util.Set;

import javafx.scene.control.ButtonBar.ButtonData;

import javax.swing.JFrame;
import javax.swing.JOptionPane;

import io.opensphere.core.datafilter.columns.MutableColumnMappingController;
import io.opensphere.core.util.fx.JFXDialog;
import io.opensphere.core.util.swing.OptionDialog;
import io.opensphere.filterbuilder.controller.FilterBuilderToolbox;
import io.opensphere.filterbuilder.filter.v1.Filter;
import io.opensphere.filterbuilder2.layers.LayerAssociationPane;
import io.opensphere.mantle.data.DataTypeInfo;

/**
 * The filter editor dialog.
 */
public class FilterEditorDialog extends OptionDialog
{
    /** The serialVersionUID. */
    private static final long serialVersionUID = 1L;

    /**
     * A title string used for a confirmation dialog.
     */
    private static final String CONF_TITLE = "Confirm Delete!";

    /**
     * A message used to indicate the filter no longer supports any layers.
     */
    private static final String CONF_MSG = "Filter no longer supports any layers and\n will be deleted.  Is this okay?";

    /**
     * The panel on which the filter editor is rendered.
     */
    private final FilterEditorPanel myEditorPanel;

    /**
     * The toolbox with which the dialog is configured.
     */
    private final FilterBuilderToolbox myTools;

    /**
     * The column controller used to change the mappings.
     */
    private final MutableColumnMappingController myColumnMappingController;

    /**
     * The filter generated by this dialog.
     */
    private final Filter myFilter;

    /**
     * A flag used to indicate that the filter is new. Defaults to false.
     */
    private final boolean myNewFilter;

    /**
     * A flag used to indicate the dialog should preserve results.
     */
    private boolean myPersistMode = true;

    /**
     * A listener used to react to new filter events.
     */
    private Runnable myNewFilterEar;

    /**
     * Constructor.
     *
     * @param parent the parent component
     * @param fbToolbox the filter builder toolbox
     * @param filter the filter
     * @param dataType the data type
     * @param isNew whether the filter is new
     */
    public FilterEditorDialog(Component parent, FilterBuilderToolbox fbToolbox, Filter filter, DataTypeInfo dataType,
            boolean isNew)
    {
        super(parent);
        setModal(false);
        myNewFilter = isNew;
        myFilter = filter;
        myTools = fbToolbox;
        myColumnMappingController = (MutableColumnMappingController)myTools.getDataFilterRegistry().getColumnMappingController();
        myEditorPanel = new FilterEditorPanel(myTools, myFilter, dataType, myNewFilter);

        setTitle(myNewFilter ? "New Filter" : "Edit Filter - " + myFilter.getName());
        setComponent(myEditorPanel);
        setPreferredSize(new Dimension(800, 600));

        addWindowListener(new WindowAdapter()
        {
            @Override
            public void windowClosed(WindowEvent e)
            {
                if (getSelection() == JOptionPane.OK_OPTION)
                {
                    saveChanges();

                    // This is necessary in Microsoft Windows to prevent a
                    // second event from firing when the filter manager dialog
                    // is closed.
                    removeWindowListener(this);
                }
            }
        });
    }

    /**
     * Creates a new dialog as a child of the supplied parent, configured with the supplied toolbox and filter.
     *
     * @param parent the parent component used to control modality.
     * @param fbToolbox the toolbox from which to configure the dialog.
     * @param filter the filter to edit.
     * @param isNew true if the filter is new, false otherwise.
     */
    public FilterEditorDialog(Component parent, FilterBuilderToolbox fbToolbox, Filter filter, boolean isNew)
    {
        super(parent);
        setModal(false);
        myNewFilter = isNew;
        myFilter = filter;
        myTools = fbToolbox;
        myColumnMappingController = (MutableColumnMappingController)myTools.getDataFilterRegistry().getColumnMappingController();
        DataTypeInfo type = getType(filter.getTypeKey());
        myEditorPanel = new FilterEditorPanel(myTools, myFilter, type, myNewFilter);

        setTitle(myNewFilter ? "New Filter" : "Edit Filter - " + myFilter.getName());
        setComponent(myEditorPanel);
        setPreferredSize(new Dimension(800, 600));

        addWindowListener(new WindowAdapter()
        {
            @Override
            public void windowClosed(WindowEvent e)
            {
                if (getSelection() == JOptionPane.OK_OPTION)
                {
                    saveChanges();

                    // This is necessary in Microsoft Windows to prevent a
                    // second event from firing when the filter manager dialog
                    // is closed.
                    removeWindowListener(this);
                }
            }
        });
    }

    /**
     * Gets the type corresponding to the supplied key.
     *
     * @param typeKey the key for which to search.
     * @return the type corresponding to the supplied key, or null if none could be found.
     */
    private DataTypeInfo getType(String typeKey)
    {
        return myTools.getMantleToolBox().getDataGroupController().findMemberById(typeKey);

        // GCD: doesn't work!
        // return tools.getMantleToolBox().getDataTypeController().
        // getDataTypeInfoForType(typeKey);
    }

    /**
     * Sets the value of the {@link #myNewFilterEar} field.
     *
     * @param pNewFilterEar the value to store in the {@link #myNewFilterEar} field.
     */
    public void setNewFilterEar(Runnable pNewFilterEar)
    {
        myNewFilterEar = pNewFilterEar;
    }

    /**
     * Sets the value of the {@link #myPersistMode} field.
     *
     * @param pPersistMode the value to store in the {@link #myPersistMode} field.
     */
    public void setPersistMode(boolean pPersistMode)
    {
        myPersistMode = pPersistMode;
    }

    /**
     * Gets the value of the {@link #myFilter} field.
     *
     * @return the value stored in the {@link #myFilter} field.
     */
    public Filter getFilter()
    {
        return myFilter;
    }

    /**
     * Persists the changes from the panel to the filter.
     */
    private void saveChanges()
    {
        // Apply the GUI model changes to the filter
        myEditorPanel.applyChanges();

        myFilter.getFilterGroup().setName(myFilter.getName());

        // Add the new filter to the controller
        if (myNewFilter)
        {
            myFilter.setActive(true, this);
            if (myPersistMode)
            {
                myTools.getController().addFilter(myFilter);
            }
            if (myNewFilterEar != null)
            {
                myNewFilterEar.run();
            }
        }
        else if (myPersistMode)
        {
            myTools.getController().updateFilter(myFilter);
        }

        // Save the filters
        if (myPersistMode)
        {
            myTools.getController().saveFilters();
        }
    }

    /**
     * Shows the U/I in which layer selections are made. The supplied filter is used to pre-populate the U/I with only those
     * layers that apply to the filter.
     *
     * @param f the filter for which to display the U/I.
     * @param fields the fields to map for the selected layers.
     * @return true if the user accepted input, false otherwise.
     */
    private boolean showLayerGui(Filter f, Set<String> fields)
    {
        LayerAssociationPane lap = new LayerAssociationPane(myColumnMappingController, myTools.getMantleToolBox(), f, fields);
        JFrame parent = myTools.getMainToolBox().getUIRegistry().getMainFrameProvider().get();
        JFXDialog dialog = new JFXDialog(parent, "Choose Layers for " + f.getName());
        dialog.setFxNode(lap);
        dialog.setConfirmer(() -> !lap.requireConfirmation() || userConf(dialog, CONF_TITLE, CONF_MSG));
        dialog.setMinimumSize(new Dimension(300, 300));
        dialog.setSize(460, 600);
        dialog.setLocationRelativeTo(parent);
        dialog.setVisible(true);
        return dialog.getResponse() == ButtonData.OK_DONE;
    }

    /**
     * Shows a confirmation dialog as a child of the supplied parent, with the supplied title and message.
     *
     * @param par the parent of the dialog for modality control.
     * @param title the title of the dialog to display.
     * @param msg the message to display in the dialog.
     * @return true if the user accepted the dialog, false otherwise.
     */
    private static boolean userConf(Component par, String title, String msg)
    {
        return JOptionPane.OK_OPTION == JOptionPane.showConfirmDialog(par, msg, title, JOptionPane.OK_CANCEL_OPTION);
    }

    /**
     * {@inheritDoc}
     * <p>
     * Tests to determine if the editor panel is dirty and needs to be saved, or if it can be closed without consequence.
     * </p>
     *
     * @return true if the editor panel may close, false otherwise.
     */
    @Override
    protected boolean mayClose()
    {
        // find the fields referenced by the filter
        Set<String> fields = myEditorPanel.getFields();

        // find the set of datatypes that must be supported
        List<String> typeKeys = myFilter.getSupportedTypes();

        // check each field to see if it is translatable to all types
        boolean supp = myColumnMappingController.supportsTypes(myFilter.getSource().getTypeKey(), fields, typeKeys);

        if (supp)
        {
            return true;
        }
        return showLayerGui(myFilter, fields);
    }
}
